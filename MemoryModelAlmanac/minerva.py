"""Implementation of traditional associative memory models from Cognitive Science in the vein of *Minerva2*."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_minerva.ipynb.

# %% auto 0
__all__ = ['Minerva2']

# %% ../nbs/01_minerva.ipynb 4
import equinox as eqx
import jax
import jax.lax as lax
import jax.numpy as jnp
import jax.random as jr
import matplotlib.pyplot as plt
import numpy as np
from beartype import beartype as typechecker
from einops import rearrange
from fastcore.basics import *
from fastcore.meta import *
from jaxtyping import Array, Float, jaxtyped

# %% ../nbs/01_minerva.ipynb 8
@jaxtyped(typechecker=typechecker)
class Minerva2(eqx.Module):
    Xi: Float[Array, "K D"]  # The stored memory traces.
    polynomial: int = 3  # The exponent to use on the similarity scores.

    def sims(
        self,
        query_state: Float[Array, " D"],  # The query "probe"
    ) -> Float[Array, " D"]:
        """Compute the similarities between a query probe and the stored memory traces."""
        return self.Xi @ query_state

    @eqx.filter_jit
    def recall(
        self,
        query_state: Float[Array, " D"],  # The query "probe"
    ) -> Float[Array, " D"]:
        """Simulate recall of a query by reconstructing it as a linear
        combination of the stored patterns.
        """
        D = query_state.shape[-1]
        sims = self.sims(query_state)
        sims = rearrange(sims, "d -> d 1")
        sims = sims**self.polynomial
        result = jnp.sum(sims * self.Xi, axis=0)
        result /= D 
        return result


# %% ../nbs/01_minerva.ipynb 12
@patch
def energy(
    self: Minerva2, 
    query: Float[Array, " D"] # The query "probe"
):
    """Compute the energy of `query`."""
    return -jnp.sum((1 / (self.polynomial)) * (self.Xi @ query) ** (self.polynomial))

# %% ../nbs/01_minerva.ipynb 26
@patch
def iterative_recall(
    self: Minerva2,
    query: Float[Array, " D"],  # The query "probe"
    nsteps: int = 200,  # How many iterations you want to perform
    normalize_with_sgn: bool = False, # Whether or not to normalize the recalled value with `jnp.sign`.
) -> None:
    """Iteratively perform recall on a query state."""
    D = query.shape[-1]

    def update_step(query, _i):
        updated_query_state = self.recall(query)
        if normalize_with_sgn:
            updated_query_state = jnp.sign(updated_query_state)
        updated_energy = self.energy(updated_query_state)
        return (updated_query_state, (updated_query_state, updated_energy))

    final_query_state, (frames, energies) = lax.scan(
        update_step, query, np.arange(nsteps)
    )
    return final_query_state, (frames, energies)

