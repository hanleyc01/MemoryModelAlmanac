"""Implementation of binary Hopfield Networks and Dense Associative Memories."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_hopfield.ipynb.

# %% auto 0
__all__ = ['GenericAM', 'ClassicalHopfield', 'DAM']

# %% ../nbs/00_hopfield.ipynb 4
import os

import equinox as eqx
import jax
import jax.lax as lax
import jax.numpy as jnp
import jax.random as jr
import matplotlib.pyplot as plt
import numpy as np
from beartype import beartype as typechecker
from beartype import typing as T
from einops import rearrange
from fastcore.basics import *
from fastcore.meta import *
from jaxtyping import Array, Float, jaxtyped


# %% ../nbs/00_hopfield.ipynb 7
@jaxtyped(typechecker=typechecker)
class GenericAM(eqx.Module):
    Xi: Float[Array, "K D"]  # The stored patterns

    def energy(self, query: Float[Array, " D"]) -> float:
        """Compute the energy of the `query` state."""
        # Left to be implemented by sub-classes.
        ...

    def async_update(self, current_query_state: Float[Array, " D"], idx: int):
        """Flip a bit in the current query state at given index if it lowers the energy."""
        flipped_query_state = current_query_state.at[idx].multiply(-1)
        current_query_energy = self.energy(current_query_state)
        flipped_query_energy = self.energy(flipped_query_state)
        does_flip_reduce_energy = (flipped_query_energy - current_query_energy) < 0
        return lax.cond(
            does_flip_reduce_energy,
            lambda: (flipped_query_state, flipped_query_energy),
            lambda: (current_query_state, current_query_energy),
        )

    @eqx.filter_jit
    def async_recall(
        self,
        initial_query_state: Float[Array, " D"],
        nsteps: int = 20_000,
        key: jax.Array = jr.PRNGKey(0),
    ):
        """Iteratively update the initial query state in order to reduce its energy."""

        def update_step(query_state, idx):
            new_query_state, new_query_energy = self.async_update(query_state, idx)
            return new_query_state, (new_query_state, new_query_energy)

        D = initial_query_state.shape[-1]
        seq = jr.choice(key, np.arange(D), shape=(nsteps,))
        final_query_state, (frames, energies) = lax.scan(
            update_step, initial_query_state, seq
        )
        return final_query_state, (frames, energies)

# %% ../nbs/00_hopfield.ipynb 12
@jaxtyped(typechecker=typechecker)
class ClassicalHopfield(GenericAM):
    """Classical Hopfield Network defined by the energy function
    in equation (1).
    """

    def energy(self, query: Float[Array, " D"]) -> float:
        return -0.5 * jnp.sum((self.Xi @ query) ** 2, axis=0)

# %% ../nbs/00_hopfield.ipynb 27
@jaxtyped(typechecker=typechecker)
class DAM(GenericAM):
    """Dense Associative Memory."""

    Xi: Float[Array, "K D"]  # The stored patterns
    polynomial: (
        int  # The polynomial to use to increase the separation in the energy function.
    )
    rectified: bool = True  # Whether or not the energy function is rectified.

    def F_n(
        self,
        sims: Float[Array, " D"],  # The dot-product similarity scores
    ):
        """The polynomial function inside of the energy function."""
        sims = sims.clip(0.0) if self.rectified else sims
        return 1 / self.polynomial * sims**self.polynomial

    def energy(self, query_state: Float[Array, " D"]) -> float:
        return -jnp.sum(self.F_n(self.Xi @ query_state))
